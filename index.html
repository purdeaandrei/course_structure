<!-- SPDX-License-Identifier: GPL-2.0-or-later -->
<!--
Course Structure.
Copyright (C) <Andrei Purdea>

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Course Structure</title>
    <style type="text/css">
        .add_button {
            position: relative;
            top: -1em;
        }
        .bad {
            background: pink;
        }
        #drophere {
            display:none;
            position: fixed;
            top: 25%;
            left: 25%;
            background-color: rgba(255,255,255,0.9);
            z-index: 10000;
            overflow:auto;
            width: 50%;
            height: 50%;
            //opacity: 0.5;
            border: 5px solid black;
            text-align: center;
        }
        #drophere b {
            position: relative;
            top: 50%;
        }
        #music_list {
            border: 1px solid black;
            padding: 5px 5px 5px 5px;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .hidden {
            display: none;
        }
        #filechooser {
            display:none
        }
        .mybutton, button {
            background-color: rgb(220, 220, 220);
            border: 1px solid grey;
        }
        .mybutton {
            padding: 5px;
        }
        .mybutton:hover, button:hover {
            background-color: rgb(200, 255, 200);
        }
        #showtime {
            display:none
        }
        #startbutton {
            font-size: 2em;
        }
        #non_song_sounds_status {
            color: red;
        }
        #songs_status {
            color: red;
        }
        canvas {
            -webkit-tap-highlight-color: transparent;
        }
    </style>

  </head>
  <body>
    <div id="setup">
        <div id="drophere"><b>You're about to drop a file!</b></div>
        What is this?: <a href="https://github.com/purdeaandrei/course_structure/blob/master/README.md">README</a>
        <h2>Structure</h2>
        <button id="unlock_structure" onclick="unlock_structure()" class="mybutton">Unlock to edit structure</button>
        <table id="course-structure-list"></table>
        <script id="line-template" type="text/template">
            <tr>
                <td>
                <button type="button" class="add_button" disabled>+</button>
                <button type="button" class="remove_button" disabled>-</button>
                </td>
                <td>{{drop-down}}</td>
                <td><input type="text" class="structure-line-minutes" size="2" value="{{minutes}}" disabled />:
                <input type="text" class="structure-line-seconds" size="2" value="{{seconds}}" disabled /></td>
                <td><input type="text" class="structure-line-title" size="16" value="{{title}}" disabled />
            </tr>
        </script>
        Total course length: <span id="total-length"></span>
        <h2>Settings</h2>
        <input type="checkbox" id="class_begins" checked><label for="class_begins">Speak "class begins" at the start of the class.</label><br/>
        <input type="checkbox" id="instructors_5_minutes" checked><label for="instructors_5_minutes">Speak "instructors, 5 minutes", before silence ends.</label><br/>
        <input type="checkbox" id="instructors_1_minute" checked><label for="instructors_1_minute">Speak "instructors, 1 minute", before <b>silence</b> ends, if silence is longer than</label> <input type="text" value="3" size="2" id="min_length_for_1min_alert" />minutes<br/>
        <input type="checkbox" id="instructors_1_minute_summary"><label for="instructors_1_minute_summary">Speak "instructors, 1 minute", before <b>summary</b> ends.</label><br/>
        <input type="checkbox" id="summary" checked><label for="summary">Speak "instructors, 5 minute summary", at the beginning of a 5 minute summary section, or "summary" if the summary section has a different length.</label><br/>
        <input type="checkbox" id="sound_at_end" checked><label for="sound_at_end">Sound at the end of the class:</label>
        <select id="what_to_play_at_end">
            <option value="drum_sound" selected>Drum</option>
            <option value="beep_sound">Beep</option>
            <option value="party_time_sound">Party Time</option>
            <option value="class_ends_sound">Class Ends</option>
            <option value="practice_time_sound">Practice Time</option>
        </select>
        <br/>
        <input type="checkbox" id="navigation_buttons_enable" checked><label for="navigation_buttons_enable">Enable a navigation buttons on the bottom left corner.</label><br/>
        <input type="checkbox" id="navigation_keyboard_shortcuts_enable" checked><label for="navigation_keyboard_shortcuts_enable">Enable keyboard shortcuts. (See <a href="https://github.com/purdeaandrei/course_structure/blob/master/README.md#keyboard-shortcuts">here</a>)</label><br/>
        <input type="checkbox" id="show_progress_bar" checked onclick="show_progress_bar_onclick()"><label for="show_progress_bar">Show progress bar</label><br/>
        &nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" id="progress_bar_seeking_enabled" checked><label for="progress_bar_seeking_enabled">Allow seeking by clicking the progress bar</label><br/>
        &nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" id="progress_bar_on_top"><label for="progress_bar_on_top">Progress bar on top</label><br/>
        <input type="checkbox" id="show_title" checked><label for="show_title">Show title of section</label><br/>
        <h2>Select Music</h2>

        <input type="file" id="filechooser" multiple accept="audio/*" onchange="handleFiles(this.files)">
        <button type="button" onclick="document.getElementById('filechooser').click()" class="mybutton">
            Click to add music to the playlist
        </button>
        <p>note: you can also drag-and-drop over this page</p>
    
        <table id="music_list" class="hidden">
            <tr>
                <th>Name</th>
                <th>Duration</th>
                <th>OffsetSeconds</th>
                <th>Controls</th>
            </tr>
        </table>

        <button id="startbutton" class="mybutton" onclick="start_showtime()">START</button>
        <br />
        <span id="non_song_sounds_status"><br />Loading non-song-sounds...</span>
        <span id="songs_status" class="hidden"><br />Loading selected songs...</span>
        <br />
        <span id="wake_lock_message">Wake lock status: <span id="wake_lock_status">unknown</span></span>
        <br />
        <div id="network_links">
            Links:
            <ul>
            <li><a href="https://github.com/purdeaandrei/course_structure/archive/refs/heads/master.zip" id="download_link">Download this tool for offline use</a> (doesn't save changes you made)</li>
            <li><a href="https://github.com/purdeaandrei/course_structure">Contribute</a></li>
            </ul>
        </div>
        <div id="padding" style="margin-bottom:800px"></div>
    
        <script id="file-template" type="text/template">
            <tr class="fileline">
                <td>
                    {{name}}
                </td>
                <td class="duration">
                    {{duration}}
                </td>
                <td>
                    <input type="text" size="2" value="{{offset}}" class="play_offset_seconds" />
                </td>
                <td>
                    <button type="button" onclick="play_song(event)">
                        <svg width="0.7em" height="0.7em">
                            <svg viewBox="0 0 1 1" height="0.7em" width="0.7em">
                                <polygon points="0,0 0,1 0.7,0.5" />
                            </svg>
                        </svg>
                    </button> <!--play-->
                    <button type="button" onclick="stop_song()">
                        <svg width="0.6em" height="0.6em">
                            <rect width="0.6em" height="0.6em" />
                        </svg>
                    </button> <!--stop-->
                    <button type="button" onclick="move_up_song(event)">
                        <svg width="0.7em" height="0.7em">
                            <svg viewBox="0 0 1 1" height="0.7em" width="0.7em">
                                <polygon points="0,0.7 1,0.7 0.5,0" />
                            </svg>
                        </svg>
                    </button> <!--up-->
                    <button type="button" onclick="move_down_song(event)">
                        <svg width="0.7em" height="0.7em">
                            <svg viewBox="0 0 1 1" height="0.7em" width="0.7em">
                                <polygon points="0,0.3 1,0.3 0.5,1" />
                            </svg>
                        </svg>
                    </button> <!--down-->
                    <button type="button" onclick="remove_song(event)">-</button>
                </td>
            </tr>
        </script>
        
    </div>
    <canvas id="showtime"></canvas>
    <div style="display:none" id="non_notification_sounds">
        <audio src="sounds/silence.mp3" id="silence_sound" preload="auto" loop></audio>
    </div>
    <div style="display:none" id="notification_sounds">
        <audio src="sounds/class_begins.mp3" id="class_begins_sound" preload="auto"></audio>
        <audio src="sounds/drum.mp3" id="drum_sound" preload="auto"></audio>
        <audio src="sounds/beep.mp3" id="beep_sound" preload="auto"></audio>
        <audio src="sounds/class_ends.mp3" id="class_ends_sound" preload="auto"></audio>
        <audio src="sounds/party_time.mp3" id="party_time_sound" preload="auto"></audio>
        <audio src="sounds/practice_time.mp3" id="practice_time_sound" preload="auto"></audio>
        <audio src="sounds/instructors_1_minute.mp3" id="instructors_1_minute_sound" preload="auto"></audio>
        <audio src="sounds/instructors_5_minutes.mp3" id="instructors_5_minutes_sound" preload="auto"></audio>
        <audio src="sounds/instructors_5_minute_summary.mp3" id="instructors_5_minute_summary_sound" preload="auto"></audio>
        <audio src="sounds/summary.mp3" id="summary_sound" preload="auto"></audio>
    </div>

    <script>
        "use strict"
        let default_structure = [
            ["silence",  3, 0, "Intro"],
            ["music",    1, 0, "Intro song"],
            ["silence", 13, 0, "Section 1"],
            ["music",    3, 0, "Song 1"],
            ["silence", 13, 0, "Section 2"],
            ["music",    3, 0, "Song 2"],
            ["silence", 13, 0, "Section 3"],
            ["music",    3, 0, "Song 3"],
            ["summary",  5, 0, "Summary"]
        ]
        let options = [
            "silence",
            "music",
            "summary"
        ]
        let can_play_through_promises = []
        for (const au of document.querySelectorAll('audio')) {
            const aupromise = new Promise(function(resolve, reject) {
                au.addEventListener('canplaythrough', (event) => {
                    resolve([au, event])
                })
                au.addEventListener('error', (event) => {
                    console.log("Error on sound " + au.id, event)
                    reject([au, event])
                })
            })
            au.addEventListener('abort', (event) => {
                console.log("Abort on sound " + au.id, event)
            })
            can_play_through_promises.push(aupromise)
        }
        Promise.all(can_play_through_promises).then(() => {
            document.getElementById('non_song_sounds_status').style.display='none'
        })
        let body = document.querySelector('body')
        let drag_counter = 0;
        body.addEventListener('drop', (ev) => {
            ev.preventDefault()
            ev.stopPropagation()
            document.getElementById('drophere').style.display='none'
            drag_counter = 0;
            let dt = ev.dataTransfer
            let files = dt.files
            handleFiles(files)
        }, false)
        body.addEventListener('dragenter', (ev) => {
            ev.preventDefault()
            document.getElementById('drophere').style.display='block'
            drag_counter += 1
        }, false)
        body.addEventListener('dragover', (ev) => {
            ev.preventDefault()
            document.getElementById('drophere').style.display='block'
        }, false)
        body.addEventListener('dragleave', () => {
            drag_counter -= 1
            if (drag_counter < 0) drag_counter = 0;
            if (drag_counter == 0) {
                document.getElementById('drophere').style.display='none'
            }
        } , false)

        let all_files = [];

        function get_file_index_from_tr(tr_el) {
            let index = 0
            let el = tr_el.previousElementSibling
            while (el) {
                if (el.classList.contains('fileline')) {
                    index += 1
                }
                el = el.previousElementSibling
            }
            return index
        }

        function log_ready_state(name, a) {
            console.log(name + " - readyState: " + a.readyState + " networkState: " + a.networkState)
        }

        function play_song_at_index(index, additional_offset = 0) {
            stop_song()
            let starting_time = parseFloat(document.querySelectorAll('#music_list .play_offset_seconds')[index].value) + max(additional_offset, 0)
            if (starting_time < 0.1) starting_time = 0
            if (all_files[index][1].duration > starting_time) {
                all_files[index][1].currentTime = starting_time
                log_ready_state(all_files[index][0], all_files[index][1])
                all_files[index][1].play()
            } else {
                console.log("Error: song " + all_files[index][0] + " was shorter than the desired starting time")
            }
        }

        function get_tr_parent_element(el) {
            while (el != null && el.tagName != "TR") {
                el = el.parentElement
            }
            return el
        }

        function play_song(ev) {
            const tr = get_tr_parent_element(ev.target)
            const index = get_file_index_from_tr(tr)
            stop_song()
            all_files[index][1].currentTime = parseFloat(tr.querySelector('.play_offset_seconds').value)
            log_ready_state(all_files[index][0], all_files[index][1])
            all_files[index][1].play()
        }
        function is_audio_playing(audio_object) {
            return !audio_object.paused && !audio_object.ended && (audio_object.currentTime > 0);
        }
        function stop_song() {
            for (const file of all_files) {
                if (file != null) {
                    if (is_audio_playing(file[1])) {
                        file[1].pause()
                        file[1].currentTime = 0
                    }
                }
            }
        }
        function remove_song(ev) {
            const tr = get_tr_parent_element(ev.target)
            const index = get_file_index_from_tr(tr)
            tr.remove()
            if (is_audio_playing(all_files[index][1])) {
                all_files[index][1].pause()
            }
            all_files.splice(index, 1)
            if (all_files.length == 0) {
                const music_list = document.getElementById('music_list')
                music_list.classList.add("hidden")
            }
        }
        function move_up_song(ev) {
            const tr = get_tr_parent_element(ev.target)
            const index = get_file_index_from_tr(tr)
            if (index > 0) {
                const before = tr.previousElementSibling
                if (before.classList.contains('fileline')) {
                    const parent = before.parentElement
                    parent.insertBefore(tr, before)
                    const t = all_files[index]
                    all_files[index] = all_files[index-1]
                    all_files[index-1] = t
                }
            }
        }
        function move_down_song(ev) {
            const tr = get_tr_parent_element(ev.target)
            const index = get_file_index_from_tr(tr)
            if (index < all_files.length - 1) {
                const next = tr.nextElementSibling
                if (next.classList.contains('fileline')) {
                    const parent = next.parentElement
                    parent.insertBefore(tr, next.nextSibling) // works with the final element too because insertBefore with a null reference will just append to the end
                    const t = all_files[index]
                    all_files[index] = all_files[index+1]
                    all_files[index+1] = t
                }
            }
        }

        function minutes_seconds(seconds) {
            if (isNaN(seconds)) return "..."
            seconds = parseInt(seconds)
            let minutes = parseInt(seconds / 60)
            seconds = seconds % 60
            if (seconds < 10)
                return minutes + ":0" + seconds
            else
                return minutes + ":" + seconds
        }

        function display_file(name, duration) {
            const temp_element = document.createElement('template')
            const music_list = document.getElementById('music_list')
            music_list.classList.remove("hidden")
            temp_element.innerHTML = document.getElementById("file-template").innerHTML.
                replaceAll("{{name}}", name).
                replaceAll("{{duration}}", minutes_seconds(duration)).
                replaceAll("{{offset}}", "0").
                trim()
            music_list.appendChild(temp_element.content);
        }

        function start_playing_silence() {
            // Play back silence, as a form of primitive wake lock, to help when the page is not in the foreground
            const silence = document.getElementById('silence_sound')
            silence.loop = true
            if (!is_audio_playing(silence)) {
                silence.play()
                silence.volume = 0.01
            }
        }

        function pause_playing_silence() {
            const silence = document.getElementById('silence_sound')
            if (is_audio_playing(silence)) {
                silence.pause()
                silence.currentTime = 0
            }
        }

        function stop_playing_silence() {
            const silence = document.getElementById('silence_sound')
            silence.loop = false
            if (!silence.ended) {
                if (silence.paused) {
                    silence.play()
                }
                silence.currentTime = silence.duration
            }
        }

        let handleFiles_called_times = 0
        function handleFiles(files) {
            handleFiles_called_times += 1
            const current_call_number = handleFiles_called_times
            for (const file of files) {
                const url = URL.createObjectURL(file)
                const a = new Audio(url)
                const apromise = new Promise(function(resolve, reject) {
                    a.addEventListener('canplaythrough', (event) => {
                        resolve([a, event])
                    })
                    a.addEventListener('error', (event) => {
                        console.log("Error on notification sound " + a.id, event)
                        reject([a, event])
                    })
                })
                a.addEventListener('abort', (event) => {
                    console.log("Abort on notification sound " + a.id, event)
                })
                a.addEventListener('durationchange', ev => {
                    for (const [i, file] of all_files.entries()) {
                        if (file[1] == a) {
                            document.querySelectorAll('#music_list .fileline .duration')[i].innerText = minutes_seconds(a.duration)
                        }
                    }
                })
                display_file(file.name, a.duration)
                all_files.push([file.name, a, 0, apromise])
            }
            document.getElementById("filechooser").value=""
            document.getElementById("songs_status").classList.remove("hidden")
            Promise.all(all_files.map(item => item[3])).then(() => {
                if (current_call_number == handleFiles_called_times) {
                    document.getElementById("songs_status").classList.add("hidden")
                }
            })
        }

        function remove_item(ev) {
            ev.target.parentElement.parentElement.remove()
            refresh_timer_and_checks()
        }

        function add_item(ev) {
            const template = document.getElementById("line-template")
            let dropdown = "<select>"
            for (const opt of options)
            {
                let selected = ""
                //if (opt == item[0]) selected = " selected"
                dropdown += '<option value="' + opt + '"' + selected + '>' + opt + '</option>'
            }
            dropdown += '</select>'
            let temp_element = document.createElement('template')
            let html = template.innerHTML.
                replaceAll("{{drop-down}}", dropdown).
                replaceAll("{{minutes}}", "TODO").
                replaceAll("{{seconds}}", "0").
                replaceAll("{{title}}", "TODO").
                replaceAll("disabled", "")
            html = html.trim()
            temp_element.innerHTML = (html).trim()
            let beforeThis = ev.target.parentElement.parentElement
            beforeThis.parentElement.insertBefore(temp_element.content.firstChild, beforeThis)
            refresh_event_listeners()
            refresh_timer_and_checks()
        }

        function refresh_event_listeners() {
            for (const element of document.querySelectorAll("#course-structure-list .remove_button")) {
                element.onclick = remove_item
            }
            for (const element of document.querySelectorAll("#course-structure-list .add_button")) {
                element.onclick = add_item
            }
            for (const element of document.querySelectorAll("#course-structure-list input")) {
                element.oninput = refresh_timer_and_checks
            }
        }

        function refresh_timer_and_checks() {
            let minutes = 0
            for (const element of document.querySelectorAll("#course-structure-list .structure-line-minutes")) {
                if (/^\s*\d+\s*$/.test(element.value)) {
                    minutes += parseInt(element.value)
                    element.classList.remove("bad")
                } else {
                    element.classList.add("bad")
                }
            }
            let seconds = 0
            for (const element of document.querySelectorAll("#course-structure-list .structure-line-seconds")) {
                if (/^\s*\d+\s*$/.test(element.value)) {
                    seconds += parseInt(element.value)
                    element.classList.remove("bad")
                } else {
                    element.classList.add("bad")
                }
            }
            minutes += Math.floor(seconds / 60)
            seconds %= 60
            document.getElementById("total-length").innerText = minutes + ":" + seconds
        }

        function unlock_structure() {
            const content = document.getElementById("course-structure-list")
            for (const e of content.querySelectorAll('button, input, select')) {
                e.disabled = false
            }
            document.getElementById("unlock_structure").style.display = "none"
        }

        function display_structure(structure) {
            const content = document.getElementById("course-structure-list")
            const template = document.getElementById("line-template")
            let html = "<tr><th>Edit</th><th>Type</th><th>Minutes:Seconds</th><th>Title</th></tr>"
            html += "<tr><td>&nbsp</td></tr>"
            for (const item of structure)
            {
                let dropdown = "<select disabled>"
                for (const opt of options)
                {
                    let selected = ""
                    if (opt == item[0]) selected = " selected"
                    dropdown += '<option value="' + opt + '"' + selected + '>' + opt + '</option>'
                }
                dropdown += '</select>'
                html += template.innerHTML.
                    replaceAll("{{drop-down}}", dropdown).
                    replaceAll("{{minutes}}", item[1]).
                    replaceAll("{{seconds}}", item[2]).
                    replaceAll("{{title}}", item[3])
            }
            html += '<tr><td><button type="button" class="add_button" disabled>+</button></tr>'
            content.innerHTML = html
            refresh_event_listeners()
            refresh_timer_and_checks()
        }
        function stop_notification_sounds() {
            for (const c of document.querySelectorAll('#notification_sounds audio')) {
                // Note: this will not catch songs, because those exist outside of the document
                if (is_audio_playing(c)) {
                    c.pause()
                    c.currentTime = 0
                }
            }
        }
        function play_notification_sound(audio_id) {
            const audio = document.getElementById(audio_id)
            log_ready_state(audio_id, audio)
            audio.play()
        }
        display_structure(default_structure)
        const canvas = document.querySelector("#showtime")
        let paused = false;
        let unpause_this_au = null
        let pause_time = null
        const click_pause = (ev) => {
            if (paused) {
                start_playing_silence()
                if (pause_time - start_time < 0.1) {
                    if (document.getElementById('class_begins').checked) {
                        play_notification_sound('class_begins_sound')
                    }
                }
                start_time += getTime() - pause_time
                if (unpause_this_au) {
                    log_ready_state("song being unpaused", unpause_this_au)
                    unpause_this_au.play()
                }
            } else {
                pause_playing_silence()
                unpause_this_au = null
                for (const file of all_files) {
                    const au = file[1];
                    if (is_audio_playing(au)) {
                        au.pause()
                        unpause_this_au = au
                        break
                    }
                }
                pause_time = getTime()
            }
            paused = !paused;
        }
        const get_current_session_time = () => {
            if (paused) {
                return pause_time - start_time
            }
            return getTime() - start_time
        }
        const get_current_index_and_offset = () => {
            const time = get_current_session_time()
            for (const [i, sect] of structure_expanded.entries()) {
                if ((time >= sect[1]) && (time < sect[2])) {
                    return [i, time - sect[1]]
                }
            }
            return [null, null]
        }
        const click_skip_next = (ev) => {
            const [i, ofs] = get_current_index_and_offset()
            if (i===null) return
            seek_to_time(structure_expanded[i][2], ev)
        }
        const click_skip_seconds = (seconds, ev) => {
            const new_session_time = max(get_current_session_time() + seconds, 0)
            seek_to_time(new_session_time, ev)
        }
        const click_reverse_seconds = (seconds, ev) => {
            const reference_session_time = min(get_current_session_time(), structure_expanded[structure_expanded.length - 1][2])
            const new_session_time = max(reference_session_time - seconds, 0)
            seek_to_time(new_session_time, ev)
        }
        const seek_to_time = (time, ev) => {
            stop_notification_sounds()
            const current_time = getTime()
            start_time = current_time - time
            pause_time = current_time
            stop_song()
            unpause_this_au = null
            previous_sect = null
            ending_sound_processed = false
            if (!paused) {
                start_playing_silence()
            }
            previous_session_time = -1
            if (!paused && time < 0.001) {
                if (document.getElementById('class_begins').checked) {
                    play_notification_sound('class_begins_sound')
                }
            }
        }
        const click_skip_prev = (ev) => {
            const [i, ofs] = get_current_index_and_offset()
            if (i===null) {
                seek_to_time(structure_expanded[structure_expanded.length - 1][1], ev)
            } else if ((ofs > 2) || (i == 0)) {
                seek_to_time(structure_expanded[i][1], ev)
            } else {
                seek_to_time(structure_expanded[i-1][1], ev)
            }
        }
        const adjust_available_time = (adjustment, ev) => {
            let [i, ofs] = get_current_index_and_offset()
            while ((i < structure_expanded.length) && (structure_expanded[i][0] == "music")) {
                i+=1
            }
            if (i < structure_expanded.length) {
                adjustment = max(structure_expanded[i][1] + ofs - structure_expanded[i][2], adjustment)
                let j = i
                while ((j < structure_expanded.length) && (structure_expanded[j][0] != "music")) j++;
                if (j >= structure_expanded.length) return
                while ((j < structure_expanded.length) && ((structure_expanded[j][0] == "music") || ((adjustment > 0) && (structure_expanded[j][2] - structure_expanded[j][1] < 0.1)))) j++;
                if (j >= structure_expanded.length) return
                adjustment = min(structure_expanded[j][2] - structure_expanded[j][1], adjustment)
                structure_expanded[i][2] += adjustment
                while (i+1 < j) {
                    i += 1
                    structure_expanded[i][1] += adjustment
                    structure_expanded[i][2] += adjustment
                }
                structure_expanded[j][1] += adjustment
            }
        }
        function toggle_fullscreen() {
            if (document.fullscreenElement == canvas) {
                document.exitFullscreen()
            } else {
                canvas.requestFullscreen()
            }
        }
        function show_progress_bar_onclick() {
            const show = document.getElementById('show_progress_bar')
            const seeking = document.getElementById('progress_bar_seeking_enabled')
            const ontop = document.getElementById('progress_bar_on_top')
            seeking.checked = show.checked
            seeking.disabled = !show.checked
            ontop.disabled = !show.checked
        }
        const calculate_sizes = () => {
            let s = {}
            s.canvas_height = canvas.height
            s.canvas_width = canvas.width
            s.progress_bar_height = s.canvas_height * 1 / 12
            s.is_progress_bar_present = document.getElementById('show_progress_bar').checked
            s.height_except_progress_bar = s.is_progress_bar_present  ?
                                           (s.canvas_height - s.progress_bar_height) :
                                           s.canvas_height
            s.is_progress_bar_on_top = document.getElementById('progress_bar_on_top').checked
            if (s.is_progress_bar_on_top) {
                s.ymin_except_progress_bar = s.progress_bar_height
                s.ymin_of_progress_bar = 0
            } else {
                s.ymin_except_progress_bar = 0
                s.ymin_of_progress_bar = s.height_except_progress_bar
            }
            s.ymax_except_progress_bar = s.ymin_except_progress_bar + s.height_except_progress_bar
            s.ymax_of_progress_bar = s.ymin_of_progress_bar + s.progress_bar_height
            s.boxs = max(min(s.canvas_width, s.height_except_progress_bar) / 9, 30)
            s.buttons_bottom_padding = 10
            s.buttons_left_padding = 10
            s.buttons_right_padding = 10
            s.buttons_spacing = 8
            s.buttons_count = 5
            s.buttons = [];
            let curr_x = s.buttons_left_padding
            for (let i=0; i<s.buttons_count; i++) {
                let button = {}
                button.ymax = s.ymax_except_progress_bar - s.buttons_bottom_padding
                button.ymin = button.ymax - s.boxs
                button.xmin = curr_x
                button.xmax = button.xmin + s.boxs
                curr_x += s.boxs + s.buttons_spacing
                s.buttons.push(button)
            }
            return s
        }
        canvas.onclick = (ev) => {
            const s = calculate_sizes()
            if (document.getElementById('navigation_buttons_enable').checked) {
                for (const [index, button] of s.buttons.entries()) {
                    if ((ev.clientY > button.ymin) &&
                        (ev.clientY < button.ymax) &&
                        (ev.clientX > button.xmin) &&
                        (ev.clientX < button.xmax))
                    {
                        switch(index) {
                            case 0: return click_pause(ev)
                            case 1: return click_skip_prev(ev)
                            case 2: return click_skip_next(ev)
                            case 3: return adjust_available_time(60, ev)
                            case 4: return adjust_available_time(-60, ev)
                        }
                        return
                    }
                }
            }
            if (s.is_progress_bar_present) {
                if (ev.clientY > s.ymin_of_progress_bar && ev.clientY < s.ymax_of_progress_bar) {
                    if (document.getElementById('progress_bar_seeking_enabled').checked) {
                        const total_length = structure_expanded[structure_expanded.length - 1][2]
                        const next_time = ev.clientX / s.canvas_width * total_length
                        seek_to_time(next_time, ev)
                    }
                    return
                }
            }
            toggle_fullscreen()
        }
        const cc = canvas.getContext("2d")
        let start_time = 0
        let ending_sound_processed = false
        let previous_sect = null
        let structure_expanded = null
        function getTime () {
            return (new Date()).getTime()/1000
        }
        function play_sound_if_needed(sect, left, previous_left, sectindex) {
            const did_we_pass_marker = (time) => {
                return (left <= time) && (previous_left > time) && (time - left < 1)
            }
            let minlen = parseInt(document.getElementById('min_length_for_1min_alert').value) * 60;
            if (isNaN(minlen)) minlen = 0
            if (sect[0] == "silence") {
                if (did_we_pass_marker(5 * 60) && document.getElementById('instructors_5_minutes').checked) {
                    play_notification_sound('instructors_5_minutes_sound')
                }
                if ((sect[2] - sect[1] >= minlen) && did_we_pass_marker(1 * 60) && document.getElementById('instructors_1_minute').checked) {
                    play_notification_sound('instructors_1_minute_sound')
                }
            }
            if (sect[0] == "summary") {
                if (document.getElementById('summary').checked) {
                    const sect_len = sect[2] - sect[1]
                    if (did_we_pass_marker(sect_len)) {
                        if (sect_len == 5 * 60) {
                            play_notification_sound('instructors_5_minute_summary_sound')
                        } else {
                            play_notification_sound('summary_sound')
                        }
                    }
                }
                if (did_we_pass_marker(1 * 60) && document.getElementById('instructors_1_minute_summary').checked) {
                    play_notification_sound('instructors_1_minute_sound')
                }
            }
            if (previous_sect && (previous_sect[0] == "music") && (sect[0] != "music")) stop_song();
            if ((sect[0] == "music") && (sect != previous_sect)) {
                if (all_files.length > 0) {
                    let next_song_to_play = 0
                    for (let j=0;j<sectindex;j++) {
                        if (structure_expanded[j][0]=="music") {
                            next_song_to_play += 1
                        }
                    }
                    next_song_to_play %= all_files.length
                    play_song_at_index(next_song_to_play, sect[2] - sect[1] - left);
                }
            }
            previous_sect = sect
        }
        function min(a,b) {
            if (a<b) return a
            return b
        }
        function max(a,b) {
            if (a>b) return a
            return b
        }
        function get_progress_bar_color_of(section_type) {
            if (section_type == "music") return "cyan"
            if (section_type == "summary") return "orange"
            return "black"
        }

        function get_title_color_of(section_type) {
            const color = get_progress_bar_color_of(section_type)
            if (color == "black") return "white"
            return color
        }

        const draw_pause_symbol_in_button = (cc, button) => {
            const boxs_w = (button.xmax - button.xmin)
            const boxs_h = (button.ymax - button.ymin)
            const d = boxs_w * 2 / 10 // d is the distance between the parallel bars
            const w = boxs_w * 2 / 10 // wxh is the size of each bar
            const h = boxs_h * 7 / 10
            const xoffset = (boxs_w-(w*2 + d)) / 2
            const yoffset = (boxs_h - h) / 2
            cc.fillRect(button.xmin + xoffset, button.ymin + yoffset, w, h)
            cc.fillRect(button.xmin + xoffset + w + d, button.ymin + yoffset, w, h)
        }

        const draw_fast_forward_rewind = (cc, xmin, xmax, ymin, ymax) => {
            cc.beginPath()
            const boxs_w = xmax - xmin
            const boxs_h = ymax - ymin
            cc.moveTo(xmin + boxs_w * 1 / 2, ymin + boxs_h / 10)
            cc.lineTo(xmin + boxs_w * 1 / 6, ymin + boxs_h / 2)
            cc.lineTo(xmin + boxs_w * 1 / 2, ymin + boxs_h - boxs_h / 10)
            cc.fill()
            cc.beginPath()
            cc.moveTo(xmin + boxs_w * 5 / 6, ymin + boxs_h / 10)
            cc.lineTo(xmin + boxs_w * 1 / 2, ymin + boxs_h / 2)
            cc.lineTo(xmin + boxs_w * 5 / 6, ymin + boxs_h - boxs_h / 10)
            cc.fill()
        }

        const calculate_clock_sizes = (time, structure_expanded, sizes) => {
            const s = sizes
            for (const [index, sect] of structure_expanded.entries()) {
                if ((time >= sect[1]) && (time < sect[2])) {
                    let cs = {}
                    const len = sect[2] - sect[1]
                    const pos = time - sect[1]
                    cs.left = len - pos
                    cs.mprogress = (60 - cs.left / 60) / 60

                    // These are the 16:9 aspect ratio variants
                    cs.x = s.canvas_width - 20
                    cs.y = s.ymin_except_progress_bar + s.height_except_progress_bar / 2
                    cs.r = min(s.canvas_width, s.height_except_progress_bar / 2)
                    cs.tx = (s.canvas_width - s.height_except_progress_bar/2) / 2
                    cs.ty = s.ymin_except_progress_bar + s.height_except_progress_bar / 2
                    cs.fontsize = Math.floor(s.canvas_width * 0.25)
                    cs.tinfo_fontsize = Math.floor(cs.fontsize / 3)
                    cs.tinfo_x = cs.tx
                    cs.tinfo_y = cs.ty + cs.tinfo_fontsize * 1.6

                    cs.textAlign = "center"
                    cs.textBaseline = "middle"
                    cs.fillStyle="white"

                    const ratio = s.canvas_width/s.height_except_progress_bar

                    if (cs.left >= 60) {
                        if (ratio < 0.9124767225325885) {
                            cs.y = s.ymin_except_progress_bar + s.height_except_progress_bar * 74 / 100
                            cs.fontsize = s.height_except_progress_bar * 0.25
                            cs.ty = s.ymin_except_progress_bar + cs.fontsize / 2 * 1.2
                            cs.tx = s.canvas_width / 2
                            cs.tinfo_fontsize = Math.floor(cs.fontsize / 3)
                            cs.tinfo_y = cs.ty + cs.tinfo_fontsize * 1.6
                            cs.tinfo_x = s.canvas_width / 3.
                            if (ratio < 0.6444981862152358) {
                                cs.fontsize = s.canvas_width * 0.35
                                cs.tinfo_fontsize = Math.floor(cs.fontsize / 3)
                            }
                        } else if (ratio < 1.3824975417895773) {
                            cs.y = s.ymin_except_progress_bar + s.height_except_progress_bar * 74 / 100
                            cs.ty = s.ymin_except_progress_bar + s.height_except_progress_bar / 3
                            cs.tx = s.canvas_width * 34 / 100
                            cs.tinfo_y = cs.ty + cs.tinfo_fontsize * 1.6
                            cs.tinfo_x = cs.tx
                        }
                    } else {
                        cs.mprogress = (60 - cs.left)/ 60
                        cs.fillStyle="red"

                        cs.tx = 10
                        cs.ty = s.ymin_except_progress_bar + 10

                        if (ratio > 1) {
                            cs.r = min(s.canvas_width / 4, s.height_except_progress_bar / 2)
                            cs.textAlign = "left"
                            cs.textBaseline = "top"
                            cs.y = s.ymin_except_progress_bar + s.height_except_progress_bar - cs.r
                            cs.tinfo_fontsize = Math.floor(cs.fontsize / 3)
                            cs.tinfo_x = s.canvas_width / 10
                            cs.tinfo_y = cs.ty + cs.fontsize
                        } else {
                            cs.r = min((s.canvas_width - 20) / 2, s.height_except_progress_bar * 60 / 100 / 2)
                            cs.y = s.ymin_except_progress_bar + s.height_except_progress_bar - cs.r - 10
                            cs.tx = s.canvas_width / 2
                            cs.ty = s.ymin_except_progress_bar + s.height_except_progress_bar / 4
                            cs.fontsize = Math.floor(s.canvas_width * 0.45)
                            if (ratio < 0.5792891319207109) {
                                cs.tinfo_fontsize = Math.floor(cs.fontsize / 3)
                                cs.tinfo_x = cs.tx
                                cs.tinfo_y = cs.ty + cs.tinfo_fontsize * 1.6
                            } else {
                                cs.tinfo_fontsize = Math.floor(cs.fontsize / 6)
                                cs.tinfo_x = s.canvas_width * 30 / 100
                                cs.tinfo_y = cs.ty + cs.tinfo_fontsize * 2.4
                            }
                        }
                        cs.x = s.canvas_width - cs.r - 10
                    }
                    cs.index = index
                    cs.title = sect[3]
                    cs.type = sect[0]
                    return cs
                }
            }
        }

        const drawClockTick = (cc, angle, clock_sizes) => {
            const cs = clock_sizes
            cc.beginPath()
            cc.arc(cs.x, cs.y, cs.r*0.95, angle - Math.PI/180, angle + Math.PI/180, false)
            cc.arc(cs.x, cs.y, cs.r*0.85, angle + Math.PI/180, angle - Math.PI/180, true)
            cc.fill()
        }

        const drawClock = (cc, clock_sizes) => {
            const cs = clock_sizes
            cc.fillStyle = cs.fillStyle
            cc.textAlign = cs.textAlign
            cc.textBaseline = cs.textBaseline

            cc.beginPath()
            cc.arc(cs.x, cs.y, cs.r * 0.8, Math.PI/2*3 + Math.PI * 2 * cs.mprogress, Math.PI/2*3 + Math.PI * 2)
            cc.lineTo(cs.x, cs.y)
            cc.fill()

            for (let i=0; i<12; i++) {
                drawClockTick(cc, Math.PI/2*3 + Math.PI * 2 - Math.PI / 2 / 3 * i, cs)
            }
            cc.strokeStyle = cc.fillStyle
            cc.lineWidth = 3.
            cc.beginPath()
            cc.arc(cs.x, cs.y, cs.r * 0.95, 0, 2 * Math.PI)
            cc.stroke()

            cc.font = "" + cs.fontsize + "px Arial"
            cc.fillText(minutes_seconds(cs.left), cs.tx, cs.ty)
            if (document.getElementById('show_title').checked) {
                cc.fillStyle = get_title_color_of(cs.type)
                cc.font = "" + cs.tinfo_fontsize + "px Arial"
                cc.fillText(cs.title, cs.tinfo_x, cs.tinfo_y)
            }
        }

        const drawTheEnd = (cc, sizes) => {
            const s = sizes
            cc.fillStyle="white"
            const fontsize = Math.floor(s.canvas_width * 0.10)
            cc.font = "" + fontsize + "px Arial"
            cc.textAlign = "center"
            cc.textBaseline = "middle"
            cc.fillText("THE END", s.canvas_width/2, s.height_except_progress_bar/2)
        }

        const drawButtons = (cc, sizes, pointerstate) => {
            const s = sizes
            const style_normal       = "rgba(255,255,255,0.2)"
            const style_normal_hover = "rgba(255,255,255,0.4)"
            const style_active       = "rgba(255,255,255,0.8)"
            const style_active_hover = "rgba(255,255,255,1.0)"

            const local_set_style = (active, button) => {
                if (areWeHoveringOverGivenButton(pointer_state, button) && !pointer_state.touch_device) {
                    if (active) {
                        cc.fillStyle=style_active_hover
                    } else {
                        cc.fillStyle=style_normal_hover
                    }
                } else {
                    if (active) {
                        cc.fillStyle=style_active
                    } else {
                        cc.fillStyle=style_normal
                    }
                }
                cc.strokeStyle=cc.fillStyle
            }

            // now draw all the squares
            for (const [index, button] of s.buttons.entries()) {
                local_set_style(index == 0 && paused, button)
                cc.strokeStyle=cc.fillStyle
                cc.strokeRect(button.xmin, button.ymin, s.boxs, s.boxs)
            }

            {
                // Draw parallel bars of pause button
                local_set_style(paused, s.buttons[0])
                cc.strokeStyle=cc.fillStyle
                draw_pause_symbol_in_button(cc, s.buttons[0])
            }

            cc.font = "" + s.boxs + "px Arial"
            cc.textAlign = "center"
            cc.textBaseline = "middle"

            local_set_style(false, s.buttons[1])

            /* Drawing for the previous-chapter button: */
            draw_fast_forward_rewind(
                cc,
                s.buttons[1].xmin,
                s.buttons[1].xmax,
                s.buttons[1].ymin,
                s.buttons[1].ymax)


            local_set_style(false, s.buttons[2])

            /* Drawing for the next-chapter button: */
            draw_fast_forward_rewind(
                cc,
                s.buttons[2].xmax, // order reversed on purpose
                s.buttons[2].xmin,
                s.buttons[2].ymin,
                s.buttons[2].ymax)

            local_set_style(false, s.buttons[3])

            cc.font = "" + (s.boxs/3) + "px Arial"
            cc.fillText("Time", s.buttons[3].xmin + s.boxs/2, s.buttons[3].ymin + s.boxs*4/5)
            cc.font = "" + (s.boxs/1) + "px Arial"
            cc.fillText("+",    s.buttons[3].xmin + s.boxs/2, s.buttons[3].ymin + s.boxs*2.25/5)

            local_set_style(false, s.buttons[4])

            cc.font = "" + (s.boxs/3) + "px Arial"
            cc.fillText("Time", s.buttons[4].xmin + s.boxs/2, s.buttons[4].ymin + s.boxs*4/5)
            cc.font = "" + (s.boxs/1) + "px Arial"
            cc.fillText("-",    s.buttons[4].xmin + s.boxs/2, s.buttons[4].ymin + s.boxs*1.8/5)
        }

        const drawProgressBar = (cc, sizes, structure_expanded, time) => {
            const s = sizes
            cc.fillStyle="red"
            const total_length = structure_expanded[structure_expanded.length - 1][2]
            const progress = time / total_length
            const tick_w = s.canvas_width / 240
            const progress_width = (s.canvas_width) * progress
            cc.fillRect(0, s.ymin_of_progress_bar + s.progress_bar_height / 2, progress_width , s.progress_bar_height / 2)
            cc.fillStyle="grey"
            cc.fillRect(progress_width, s.ymin_of_progress_bar + s.progress_bar_height / 2, s.canvas_width - progress_width , s.progress_bar_height / 2)
            for (const f of structure_expanded) {
                const fill_color = get_progress_bar_color_of(f[0])
                const right_edge = f[2] * s.canvas_width / total_length
                const left_edge = f[1] * s.canvas_width / total_length
                cc.fillStyle=fill_color
                cc.fillRect(left_edge, s.ymin_of_progress_bar, right_edge - left_edge, s.progress_bar_height / 2)
            }
            cc.fillStyle="white"
            for (let i=0; i < structure_expanded.length - 1; i++) { // loop over pairwise
                const f = structure_expanded[i]
                const fill_color = get_progress_bar_color_of(f[0])
                const fill_color_next = get_progress_bar_color_of(structure_expanded[i+1][0])
                if (fill_color_next == fill_color) {
                    const tick_x = f[2] * s.canvas_width / total_length
                    // Print a tick, if color is the same
                    cc.beginPath()
                    cc.moveTo(tick_x - tick_w, s.ymin_of_progress_bar)
                    cc.lineTo(tick_x + tick_w, s.ymin_of_progress_bar)
                    cc.lineTo(tick_x + tick_w, s.ymin_of_progress_bar + s.progress_bar_height / 4)
                    cc.lineTo(tick_x, s.ymin_of_progress_bar + s.progress_bar_height / 2)
                    cc.lineTo(tick_x - tick_w, s.ymin_of_progress_bar + s.progress_bar_height / 4)
                    cc.fill()
                }
            }
        }

        const areWeHoveringOverTheProgressBar = (pointer_state, sizes) => {
            return pointer_state.last_canvasY != null &&
                   pointer_state.last_canvasY > sizes.ymin_of_progress_bar &&
                   pointer_state.last_canvasY < sizes.ymax_of_progress_bar
        }

        const areWeHoveringOverGivenButton = (pointer_state, button) => {
                return (pointer_state.last_canvasY > button.ymin) &&
                       (pointer_state.last_canvasY < button.ymax) &&
                       (pointer_state.last_canvasX > button.xmin) &&
                       (pointer_state.last_canvasX < button.xmax)
        }

        const drawGreyTintOverProgressBar = (cc, pointer_state, sizes) => {
            cc.fillStyle="rgba(255,255,255,0.4)"
            cc.fillRect(0, sizes.ymin_of_progress_bar, pointer_state.last_canvasX, sizes.progress_bar_height)
        }

        let pointer_state = {
            last_canvasX: null,
            last_canvasY: null,
            touch_device: false,
            visible: true
        }

        const set_up_mouse_autohide = () => {
            let mouse_timer = null
            body.addEventListener("mousemove", () => {
                pointer_state.visible = true
                if (mouse_timer) {
                    clearTimeout(mouse_timer)
                    mouse_timer = null
                }
                mouse_timer = setTimeout(() => {
                    mouse_timer = null
                    pointer_state.visible = false
                }, 3000)
            })
        }

        function drawCurrentFrame() {
            const s = calculate_sizes()
            const time = get_current_session_time()
            let cursor_style = "initial"

            cc.fillStyle="black"
            cc.fillRect(0, 0, s.canvas_width, s.canvas_height)

            const cs = calculate_clock_sizes(time, structure_expanded, s)
            if (cs) {
                drawClock(cc, cs)
            } else {
                drawTheEnd(cc, s)
            }

            if (document.getElementById('navigation_buttons_enable').checked) {
                drawButtons(cc, s, pointer_state)

                for (const button of s.buttons) {
                    if (areWeHoveringOverGivenButton(pointer_state, button)) {
                        cursor_style = "pointer"
                    }
                }
            }
            if (s.is_progress_bar_present) {
                drawProgressBar(cc, s, structure_expanded, time)
                if (areWeHoveringOverTheProgressBar(pointer_state, s)) {
                    if (document.getElementById('progress_bar_seeking_enabled').checked) {
                        cursor_style = "col-resize"
                        if (!pointer_state.touch_device) {
                            drawGreyTintOverProgressBar(cc, pointer_state, s)
                        }
                    } else {
                        cursor_style = "not-allowed"
                    }
                }
            }
            if (pointer_state.visible) {
                canvas.style.cursor = cursor_style
            } else {
                canvas.style.cursor = "none"
            }
        }

        let previous_session_time = -1
        function performActions() {
            let time = get_current_session_time()
            let ii = 0
            let found = false
            let message = "The End"
            for (const [ii, sect] of structure_expanded.entries()) {
                if ((time >= sect[1]) && (time < sect[2])) {
                    let len = sect[2] - sect[1]
                    let pos = time - sect[1]
                    let left = len - pos
                    let previous_left = len - (previous_session_time - sect[1])
                    if (!paused)
                    {
                        play_sound_if_needed(sect, left, previous_left, ii)
                    }
                    found = true
                    message = "" + ii + ": " + sect[0]
                    break
                }
            }
            if (!found) {
                if (!ending_sound_processed) {
                    stop_playing_silence()
                    if (document.getElementById('sound_at_end').checked) {
                        let what = document.getElementById('what_to_play_at_end').value
                        play_notification_sound(what)
                    }
                    ending_sound_processed = true
                }
            }
            previous_session_time = time
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: message,
                    artist: 'Course Structure',
                })
                if (paused) {
                    navigator.mediaSession.playbackState = "paused"
                } else {
                    navigator.mediaSession.playbackState = "playing"
                }
                navigator.mediaSession.setActionHandler('play', click_pause)
                navigator.mediaSession.setActionHandler('pause', click_pause)
                navigator.mediaSession.setActionHandler('nexttrack', click_skip_next)
                navigator.mediaSession.setActionHandler('previoustrack', click_skip_prev)
                navigator.mediaSession.setActionHandler('seekforward', function() {
                    click_skip_seconds(10)
                })
                navigator.mediaSession.setActionHandler('seekbackward', function() {
                    click_reverse_seconds(10)
                })
                navigator.mediaSession.setActionHandler('stop', function() {
                    seek_to_time(structure_expanded[structure_expanded.length - 1][2], ev)
                })
            }
        }
        const anim = () => {
            drawCurrentFrame()
            requestAnimationFrame(anim)
        }
        const actions = () => {
            performActions()
            setTimeout(actions, 1000 / 20)
        }
        const resizeCanvas = () => {
            let w = window.innerWidth;
            let h = window.innerHeight;
            canvas.style.position="absolute";
            canvas.style.left="0px";
            canvas.width = w;
            canvas.height = h;
        };

        function getCurrentStructure() {
            let list = []
            for (const tr of document.querySelectorAll("#course-structure-list tr")) {
                const sel = tr.querySelector("select")
                if (sel) {
                    const min = parseFloat(tr.querySelector(".structure-line-minutes").value)
                    const sec = parseFloat(tr.querySelector(".structure-line-seconds").value)
                    const title = tr.querySelector(".structure-line-title").value
                    list.push([sel.value, min, sec, title])
                }
            }
            return list
        }

        function expandStructure(structure) {
            let acc = 0
            let list = []
            for (const item of structure) {
                const secs = item[1] * 60 + item[2]
                list.push([item[0], acc, acc+secs, item[3]])
                acc += secs
            }
            return list
        }

        const wake_lock_message = document.getElementById("wake_lock_message")
        const wake_lock_status = document.getElementById("wake_lock_status")
        if ('wakeLock' in navigator) {
            wake_lock_status.innerText = "request pending"
            wake_lock_message.style.color = "red"
            let wake_lock = null;
            async function request_wake_lock() {
                try {
                    wake_lock = await navigator.wakeLock.request('screen')
                    wake_lock.addEventListener('release', () => {
                        console.log("wake lock was released")
                        wake_lock_message.style.color = "red"
                        wake_lock_status.innerText = "released"
                    })
                    console.log("wake lock was acquired")
                    wake_lock_status.innerText = "OK, appears to have been successfully acquired"
                    wake_lock_message.style.color = "#00E000"
                } catch (err) {
                    console.log("Error while acquiring wake lock")
                    wake_lock_message.style.color = "red"
                    wake_lock_status.innerText = "error while acquiring"
                }
            }
            request_wake_lock()
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    request_wake_lock()
                }
            })
        } else {
            wake_lock_message.style.color = "red"
            if (window.location.protocol == "http:") {
                wake_lock_status.innerText = "not supported (could be because this site is being served as non-secure http://. Try downloading, and running locally.)"
            } else {
                wake_lock_status.innerText = "not supported"
            }
        }

        if (window.location.hostname!="purdeaandrei.github.io") {
            document.getElementById("network_links").style.display="none"
        }

        function start_showtime() {
            if (all_files.length==0) {
                alert("ERROR: you must have at least one song added to the playlist!")
                return
            }
            stop_song()
            set_up_mouse_autohide()
            structure_expanded = expandStructure(getCurrentStructure())
            document.querySelector("#setup").style.display="none"
            canvas.style.display="block"
            document.body.style.background="black"
            start_time = getTime()
            paused = false
            ending_sound_processed = false
            start_playing_silence()
            if (document.getElementById('class_begins').checked) {
                play_notification_sound('class_begins_sound')
            }
            document.getElementsByTagName('body')[0].style.margin="0 0 0 0"
            resizeCanvas()
            anim()
            actions()
            window.onresize = () => {
                resizeCanvas();
                drawCurrentFrame();
            };
            if (document.getElementById('navigation_keyboard_shortcuts_enable').checked) {
                document.addEventListener('keydown', (event) => {
                    if (event.isComposing || event.keyCode === 229) {
                        return;
                    }
                    switch (event.keyCode) {
                        case 70: /* F pressed */
                            toggle_fullscreen()
                            break
                        case 32: /* space */
                            click_pause(event)
                            break
                        case 34: /* page-down */
                            click_skip_prev(event)
                            break
                        case 33: /* page-up */
                            click_skip_next(event)
                            break
                        case 39: /* right arrow */
                            click_skip_seconds(10, event)
                            break
                        case 37: /* left arrow */
                            click_reverse_seconds(10, event)
                            break
                        case 38: /* up arrow */
                            click_skip_seconds(60, event)
                            break
                        case 40: /* down arrow */
                            click_reverse_seconds(60, event)
                            break
                        case 107: /* numpad + */
                        case 187: /* alpha key with plus symbol (next to backspace) */
                            adjust_available_time(60, event)
                            break
                        case 109: /* numpad - */
                        case 189: /* alpha key with minus symbol (second one next to backspace) */
                            adjust_available_time(-60, event)
                            break
                    }
                })
            }
            if (document.getElementById('show_progress_bar').checked) {
                canvas.addEventListener('mousemove', (event) => {
                    const rect = canvas.getBoundingClientRect()
                    pointer_state.last_canvasX = event.clientX - rect.left
                    pointer_state.last_canvasY = event.clientY - rect.top
                })
                canvas.addEventListener('mouseover', (event) => {
                    const rect = canvas.getBoundingClientRect()
                    pointer_state.last_canvasX = event.clientX - rect.left
                    pointer_state.last_canvasY = event.clientY - rect.top
                })
                canvas.addEventListener('mouseout', (event) => {
                    pointer_state.last_canvasX = null
                    pointer_state.last_canvasY = null
                })
                canvas.addEventListener('touchstart', (event) => {
                    pointer_state.touch_device = true;
                })
                canvas.addEventListener('touchend', (event) => {
                    pointer_state.touch_device = true;
                })
            }
        }
    </script>
  </body>
</html>
