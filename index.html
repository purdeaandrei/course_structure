<!-- SPDX-License-Identifier: GPL-2.0-or-later -->
<!--
Course Structure.
Copyright (C) <Andrei Purdea>

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Course Structure</title>
    <style type="text/css">
        .add_button {
            position: relative;
            top: -1em;
        }
        .bad {
            background: pink;
        }
        #drophere {
            display:none;
            position: fixed;
            top: 25%;
            left: 25%;
            background-color: rgba(255,255,255,0.9);
            z-index: 10000;
            overflow:auto;
            width: 50%;
            height: 50%;
            //opacity: 0.5;
            border: 5px solid black;
            text-align: center;
        }
        #drophere b {
            position: relative;
            top: 50%;
        }
        #music_list {
            border: 1px solid black;
            padding: 5px 5px 5px 5px;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .hidden {
            display: none;
        }
        #filechooser {
            display:none
        }
        .mybutton, button {
            background-color: rgb(220, 220, 220);
            border: 1px solid grey;
        }
        .mybutton {
            padding: 5px;
        }
        .mybutton:hover, button:hover {
            background-color: rgb(200, 255, 200);
        }
        #showtime {
            display:none
        }
        #startbutton {
            font-size: 2em;
        }
        #non_song_sounds_status {
            color: red;
        }
        #songs_status {
            color: red;
        }
    </style>

  </head>
  <body>
    <div id="setup">
        <div id="drophere"><b>You're about to drop a file!</b></div>
        What is this?: <a href="https://github.com/purdeaandrei/course_structure/blob/master/README.md">README</a>
        <h2>Structure</h2>
        <button id="unlock_structure" onclick="unlock_structure()" class="mybutton">Unlock to edit structure</button>
        <table id="course-structure-list"></table>
        <script id="line-template" type="text/template">
            <tr>
                <td>
                <button type="button" class="add_button" disabled>+</button>
                <button type="button" class="remove_button" disabled>-</button>
                </td>
                <td>{{drop-down}}</td>
                <td><input type="text" class="structure-line-minutes" size="2" value="{{minutes}}" disabled />:
                <input type="text" class="structure-line-seconds" size="2" value="{{seconds}}" disabled /></td>
            </tr>
        </script>
        Total course length: <span id="total-length"></span>
        <h2>Settings</h2>
        <input type="checkbox" id="class_begins" checked><label for="class_begins">Speak "class begins" at the start of the class.</label><br/>
        <input type="checkbox" id="instructors_5_minutes" checked><label for="instructors_5_minutes">Speak "instructors, 5 minutes", before silence ends.</label><br/>
        <input type="checkbox" id="instructors_1_minute" checked><label for="instructors_1_minute">Speak "instructors, 1 minute", before <b>silence</b> ends, if silence is longer than</label> <input type="text" value="3" size="2" id="min_length_for_1min_alert" />minutes<br/>
        <input type="checkbox" id="instructors_1_minute_summary"><label for="instructors_1_minute_summary">Speak "instructors, 1 minute", before <b>summary</b> ends.</label><br/>
        <input type="checkbox" id="summary" checked><label for="summary">Speak "instructors, 5 minute summary", at the beginning of a 5 minute summary section, or "summary" if the summary section has a different length.</label><br/>
        <input type="checkbox" id="sound_at_end" checked><label for="sound_at_end">Sound at the end of the class:</label>
        <select id="what_to_play_at_end">
            <option value="drum_sound" selected>Drum</option>
            <option value="beep_sound">Beep</option>
            <option value="party_time_sound">Party Time</option>
            <option value="class_ends_sound">Class Ends</option>
            <option value="practice_time_sound">Practice Time</option>
        </select>
        <br/>
        <input type="checkbox" id="navigation_buttons_enable" checked><label for="navigation_buttons_enable">Enable a navigation buttons on the bottom left corner.</label><br/>
        <input type="checkbox" id="navigation_keyboard_shortcuts_enable" checked><label for="navigation_keyboard_shortcuts_enable">Enable keyboard shortcuts. (See <a href="https://github.com/purdeaandrei/course_structure/blob/master/README.md#keyboard-shortcuts">here</a>)</label><br/>
        <input type="checkbox" id="show_progress_bar" checked onclick="show_progress_bar_onclick()"><label for="show_progress_bar">Show progress bar</label><br/>
        &nbsp;&nbsp;&nbsp;&nbsp;<input type="checkbox" id="progress_bar_seeking_enabled" checked><label for="progress_bar_seeking_enabled">Allow seeking by clicking the progress bar</label><br/>
        <h2>Select Music</h2>

        <input type="file" id="filechooser" multiple accept="audio/*" onchange="handleFiles(this.files)">
        <button type="button" onclick="document.getElementById('filechooser').click()" class="mybutton">
            Click to add music to the playlist
        </button>
        <p>note: you can also drag-and-drop over this page</p>
    
        <table id="music_list" class="hidden">
            <tr>
                <th>Name</th>
                <th>Duration</th>
                <th>OffsetSeconds</th>
                <th>Controls</th>
            </tr>
        </table>

        <button id="startbutton" class="mybutton" onclick="start_showtime()">START</button>
        <br />
        <span id="non_song_sounds_status"><br />Loading non-song-sounds...</span>
        <span id="songs_status" class="hidden"><br />Loading selected songs...</span>
        <br />
        <span id="wake_lock_message">Wake lock status: <span id="wake_lock_status">unknown</span></span>
        <br />
        <div id="network_links">
            Links:
            <ul>
            <li><a href="https://github.com/purdeaandrei/course_structure/archive/refs/heads/master.zip" id="download_link">Download this tool for offline use</a> (doesn't save changes you made)</li>
            <li><a href="https://github.com/purdeaandrei/course_structure">Contribute</a></li>
            </ul>
        </div>
        <div id="padding" style="margin-bottom:800px"></div>
    
        <script id="file-template" type="text/template">
            <tr class="fileline">
                <td>
                    {{name}}
                </td>
                <td class="duration">
                    {{duration}}
                </td>
                <td>
                    <input type="text" size="2" value="{{offset}}" class="play_offset_seconds" />
                </td>
                <td>
                    <button type="button" onclick="play_song(event)">
                        <svg width="0.7em" height="0.7em">
                            <svg viewBox="0 0 1 1" height="0.7em" width="0.7em">
                                <polygon points="0,0 0,1 0.7,0.5" />
                            </svg>
                        </svg>
                    </button> <!--play-->
                    <button type="button" onclick="stop_song()">
                        <svg width="0.6em" height="0.6em">
                            <rect width="0.6em" height="0.6em" />
                        </svg>
                    </button> <!--stop-->
                    <button type="button" onclick="move_up_song(event)">
                        <svg width="0.7em" height="0.7em">
                            <svg viewBox="0 0 1 1" height="0.7em" width="0.7em">
                                <polygon points="0,0.7 1,0.7 0.5,0" />
                            </svg>
                        </svg>
                    </button> <!--up-->
                    <button type="button" onclick="move_down_song(event)">
                        <svg width="0.7em" height="0.7em">
                            <svg viewBox="0 0 1 1" height="0.7em" width="0.7em">
                                <polygon points="0,0.3 1,0.3 0.5,1" />
                            </svg>
                        </svg>
                    </button> <!--down-->
                    <button type="button" onclick="remove_song(event)">-</button>
                </td>
            </tr>
        </script>
        
    </div>
    <canvas id="showtime"></canvas>
    <div style="display:none" id="non_notification_sounds">
        <audio src="sounds/silence.mp3" id="silence_sound" preload="auto" loop></audio>
    </div>
    <div style="display:none" id="notification_sounds">
        <audio src="sounds/class_begins.mp3" id="class_begins_sound" preload="auto"></audio>
        <audio src="sounds/drum.mp3" id="drum_sound" preload="auto"></audio>
        <audio src="sounds/beep.mp3" id="beep_sound" preload="auto"></audio>
        <audio src="sounds/class_ends.mp3" id="class_ends_sound" preload="auto"></audio>
        <audio src="sounds/party_time.mp3" id="party_time_sound" preload="auto"></audio>
        <audio src="sounds/practice_time.mp3" id="practice_time_sound" preload="auto"></audio>
        <audio src="sounds/instructors_1_minute.mp3" id="instructors_1_minute_sound" preload="auto"></audio>
        <audio src="sounds/instructors_5_minutes.mp3" id="instructors_5_minutes_sound" preload="auto"></audio>
        <audio src="sounds/instructors_5_minute_summary.mp3" id="instructors_5_minute_summary_sound" preload="auto"></audio>
        <audio src="sounds/summary.mp3" id="summary_sound" preload="auto"></audio>
    </div>

    <script>
        "use strict"
        let default_structure = [
            ["silence", 2, 0],
            ["music", 2, 0],
            ["silence", 13, 0],
            ["music", 2, 0],
            ["silence", 13, 0],
            ["music", 2, 0],
            ["silence", 13, 0],
            ["music", 2, 0],
            ["summary", 5, 0]
        ]
        let options = [
            "silence",
            "music",
            "summary"
        ]
        let can_play_through_promises = []
        for (const au of document.querySelectorAll('audio')) {
            const aupromise = new Promise(function(resolve, reject) {
                au.addEventListener('canplaythrough', (event) => {
                    resolve([au, event])
                })
                au.addEventListener('error', (event) => {
                    console.log("Error on sound " + au.id, event)
                    reject([au, event])
                })
            })
            au.addEventListener('abort', (event) => {
                console.log("Abort on sound " + au.id, event)
            })
            can_play_through_promises.push(aupromise)
        }
        Promise.all(can_play_through_promises).then(() => {
            document.getElementById('non_song_sounds_status').style.display='none'
        })
        let body = document.querySelector('body')
        let drag_counter = 0;
        body.addEventListener('drop', (ev) => {
            ev.preventDefault()
            ev.stopPropagation()
            document.getElementById('drophere').style.display='none'
            drag_counter = 0;
            let dt = ev.dataTransfer
            let files = dt.files
            handleFiles(files)
        }, false)
        body.addEventListener('dragenter', (ev) => {
            ev.preventDefault()
            document.getElementById('drophere').style.display='block'
            drag_counter += 1
        }, false)
        body.addEventListener('dragover', (ev) => {
            ev.preventDefault()
            document.getElementById('drophere').style.display='block'
        }, false)
        body.addEventListener('dragleave', () => {
            drag_counter -= 1
            if (drag_counter < 0) drag_counter = 0;
            if (drag_counter == 0) {
                document.getElementById('drophere').style.display='none'
            }
        } , false)

        let all_files = [];

        function get_file_index_from_tr(tr_el) {
            let index = 0
            let el = tr_el.previousElementSibling
            while (el) {
                if (el.classList.contains('fileline')) {
                    index += 1
                }
                el = el.previousElementSibling
            }
            return index
        }

        function log_ready_state(name, a) {
            console.log(name + " - readyState: " + a.readyState + " networkState: " + a.networkState)
        }

        function play_song_at_index(index, additional_offset = 0) {
            stop_song()
            let starting_time = parseFloat(document.querySelectorAll('#music_list .play_offset_seconds')[index].value) + max(additional_offset, 0)
            if (starting_time < 0.1) starting_time = 0
            if (all_files[index][1].duration > starting_time) {
                all_files[index][1].currentTime = starting_time
                log_ready_state(all_files[index][0], all_files[index][1])
                all_files[index][1].play()
            } else {
                console.log("Error: song " + all_files[index][0] + " was shorter than the desired starting time")
            }
        }

        function get_tr_parent_element(el) {
            while (el != null && el.tagName != "TR") {
                el = el.parentElement
            }
            return el
        }

        function play_song(ev) {
            const tr = get_tr_parent_element(ev.target)
            const index = get_file_index_from_tr(tr)
            stop_song()
            all_files[index][1].currentTime = parseFloat(tr.querySelector('.play_offset_seconds').value)
            log_ready_state(all_files[index][0], all_files[index][1])
            all_files[index][1].play()
        }
        function stop_song() {
            for (const file of all_files) {
                if (file != null) {
                    if (!file[1].paused && !file[1].ended && (file[1].currentTime>0)) {
                        file[1].pause()
                        file[1].currentTime = 0
                    }
                }
            }
        }
        function remove_song(ev) {
            const tr = get_tr_parent_element(ev.target)
            const index = get_file_index_from_tr(tr)
            tr.remove()
            all_files.splice(index, 1)
            if (all_files.length == 0) {
                const music_list = document.getElementById('music_list')
                music_list.classList.add("hidden")
            }
        }
        function move_up_song(ev) {
            const tr = get_tr_parent_element(ev.target)
            const index = get_file_index_from_tr(tr)
            if (index > 0) {
                const before = tr.previousElementSibling
                if (before.classList.contains('fileline')) {
                    const parent = before.parentElement
                    parent.insertBefore(tr, before)
                    const t = all_files[index]
                    all_files[index] = all_files[index-1]
                    all_files[index-1] = t
                }
            }
        }
        function move_down_song(ev) {
            const tr = get_tr_parent_element(ev.target)
            const index = get_file_index_from_tr(tr)
            if (index < all_files.length - 1) {
                const next = tr.nextElementSibling
                if (next.classList.contains('fileline')) {
                    const parent = next.parentElement
                    parent.insertBefore(tr, next.nextSibling) // works with the final element too because insertBefore with a null reference will just append to the end
                    const t = all_files[index]
                    all_files[index] = all_files[index+1]
                    all_files[index+1] = t
                }
            }
        }

        function minutes_seconds(seconds) {
            if (isNaN(seconds)) return "..."
            seconds = parseInt(seconds)
            let minutes = parseInt(seconds / 60)
            seconds = seconds % 60
            if (seconds < 10)
                return minutes + ":0" + seconds
            else
                return minutes + ":" + seconds
        }

        function display_file(name, duration) {
            const temp_element = document.createElement('template')
            const music_list = document.getElementById('music_list')
            music_list.classList.remove("hidden")
            temp_element.innerHTML = document.getElementById("file-template").innerHTML.
                replaceAll("{{name}}", name).
                replaceAll("{{duration}}", minutes_seconds(duration)).
                replaceAll("{{offset}}", "0").
                trim()
            music_list.appendChild(temp_element.content);
        }

        function start_playing_silence() {
            // Play back silence, as a form of primitive wake lock, to help when the page is not in the foreground
            const silence = document.getElementById('silence_sound')
            silence.loop = true
            if (silence.paused || silence.ended || (silence.currentTime <= 0)) {
                silence.play()
                silence.volume = 0.01
            }
        }

        function pause_playing_silence() {
            const silence = document.getElementById('silence_sound')
            if (!silence.paused && !silence.ended && (silence.currentTime > 0)) {
                silence.pause()
                silence.currentTime = 0
            }
        }

        function stop_playing_silence() {
            const silence = document.getElementById('silence_sound')
            silence.loop = false
            if (!silence.ended) {
                if (silence.paused) {
                    silence.play()
                }
                silence.currentTime = silence.duration
            }
        }

        let handleFiles_called_times = 0
        function handleFiles(files) {
            handleFiles_called_times += 1
            const current_call_number = handleFiles_called_times
            for (const file of files) {
                const url = URL.createObjectURL(file)
                const a = new Audio(url)
                const apromise = new Promise(function(resolve, reject) {
                    a.addEventListener('canplaythrough', (event) => {
                        resolve([a, event])
                    })
                    a.addEventListener('error', (event) => {
                        console.log("Error on notification sound " + a.id, event)
                        reject([a, event])
                    })
                })
                a.addEventListener('abort', (event) => {
                    console.log("Abort on notification sound " + a.id, event)
                })
                a.addEventListener('durationchange', ev => {
                    for (let i=0;i<all_files.length;i++) {
                        if (all_files[i][1] == a) {
                            document.querySelectorAll('#music_list .fileline .duration')[i].innerText = minutes_seconds(a.duration)
                        }
                    }
                })
                display_file(file.name, a.duration)
                all_files.push([file.name, a, 0, apromise])
            }
            document.getElementById("filechooser").value=""
            document.getElementById("songs_status").classList.remove("hidden")
            Promise.all(all_files.map(item => item[3])).then(() => {
                if (current_call_number == handleFiles_called_times) {
                    document.getElementById("songs_status").classList.add("hidden")
                }
            })
        }

        function remove_item(ev) {
            ev.target.parentElement.parentElement.remove()
            refresh_timer_and_checks()
        }

        function add_item(ev) {
            const template = document.getElementById("line-template")
            let dropdown = "<select>"
            for (const opt of options)
            {
                let selected = ""
                //if (opt == item[0]) selected = " selected"
                dropdown += '<option value="' + opt + '"' + selected + '>' + opt + '</option>'
            }
            dropdown += '</select>'
            let temp_element = document.createElement('template')
            let html = template.innerHTML.
                replaceAll("{{drop-down}}", dropdown).
                replaceAll("{{minutes}}", "TODO").
                replaceAll("{{seconds}}", "0").
                replaceAll("disabled", "")
            html = html.trim()
            temp_element.innerHTML = (html).trim()
            let beforeThis = ev.target.parentElement.parentElement
            beforeThis.parentElement.insertBefore(temp_element.content.firstChild, beforeThis)
            refresh_event_listeners()
            refresh_timer_and_checks()
        }

        function refresh_event_listeners() {
            for (const element of document.querySelectorAll("#course-structure-list .remove_button")) {
                element.onclick = remove_item
            }
            for (const element of document.querySelectorAll("#course-structure-list .add_button")) {
                element.onclick = add_item
            }
            for (const element of document.querySelectorAll("#course-structure-list input")) {
                element.oninput = refresh_timer_and_checks
            }
        }

        function refresh_timer_and_checks() {
            let minutes = 0
            for (const element of document.querySelectorAll("#course-structure-list .structure-line-minutes")) {
                if (/^\s*\d+\s*$/.test(element.value)) {
                    minutes += parseInt(element.value)
                    element.classList.remove("bad")
                } else {
                    element.classList.add("bad")
                }
            }
            let seconds = 0
            for (const element of document.querySelectorAll("#course-structure-list .structure-line-seconds")) {
                if (/^\s*\d+\s*$/.test(element.value)) {
                    seconds += parseInt(element.value)
                    element.classList.remove("bad")
                } else {
                    element.classList.add("bad")
                }
            }
            minutes += Math.floor(seconds / 60)
            seconds %= 60
            document.getElementById("total-length").innerText = minutes + ":" + seconds
        }

        function unlock_structure() {
            const content = document.getElementById("course-structure-list")
            for (const e of content.querySelectorAll('button, input, select')) {
                e.disabled = false
            }
            document.getElementById("unlock_structure").style.display = "none"
        }

        function display_structure(structure) {
            const content = document.getElementById("course-structure-list")
            const template = document.getElementById("line-template")
            let html = "<tr><th>Edit</th><th>Type</th><th>Minutes:Seconds</th></tr>"
            html += "<tr><td>&nbsp</td></tr>"
            for (const item of structure)
            {
                let dropdown = "<select disabled>"
                for (const opt of options)
                {
                    let selected = ""
                    if (opt == item[0]) selected = " selected"
                    dropdown += '<option value="' + opt + '"' + selected + '>' + opt + '</option>'
                }
                dropdown += '</select>'
                html += template.innerHTML.
                    replaceAll("{{drop-down}}", dropdown).
                    replaceAll("{{minutes}}", item[1]).
                    replaceAll("{{seconds}}", item[2])
            }
            html += '<tr><td><button type="button" class="add_button" disabled>+</button></tr>'
            content.innerHTML = html
            refresh_event_listeners()
            refresh_timer_and_checks()
        }
        function stop_notification_sounds() {
            for (const c of document.querySelectorAll('#notification_sounds audio')) {
                // Note: this will not catch songs, because those exist outside of the document
                if (!c.paused && !c.ended && c.currentTime > 0) {
                    c.pause()
                    c.currentTime = 0
                }
            }
        }
        function play_notification_sound(audio_id) {
            const audio = document.getElementById(audio_id)
            log_ready_state(audio_id, audio)
            audio.play()
        }
        display_structure(default_structure)
        const canvas = document.querySelector("#showtime")
        let paused = false;
        let unpause_this_au = null
        let pause_time = null
        const click_pause = (ev) => {
            if (paused) {
                start_playing_silence()
                if (pause_time - start_time < 0.1) {
                    if (document.getElementById('class_begins').checked) {
                        play_notification_sound('class_begins_sound')
                    }
                }
                start_time += getTime() - pause_time
                if (unpause_this_au) {
                    log_ready_state("song being unpaused", unpause_this_au)
                    unpause_this_au.play()
                }
            } else {
                pause_playing_silence()
                unpause_this_au = null
                for (let i=0;i<all_files.length;i++) {
                    const au = all_files[i][1];
                    if ((au.currentTime > 0) && !au.paused && !au.ended) {
                        au.pause()
                        unpause_this_au = au
                        break
                    }
                }
                pause_time = getTime()
            }
            paused = !paused;
        }
        const get_current_session_time = () => {
            if (paused) {
                return pause_time - start_time
            }
            return getTime() - start_time
        }
        const get_current_index_and_offset = () => {
            const time = get_current_session_time()
            for (let i=0;i<structure_expanded.length;i++) {
                let sect = structure_expanded[i];
                if ((time >= sect[1]) && (time < sect[2])) {
                    return [i, time - sect[1]]
                }
            }
            return [null, null]
        }
        const click_skip_next = (ev) => {
            const [i, ofs] = get_current_index_and_offset()
            if (i===null) return
            seek_to_time(structure_expanded[i][2], ev)
        }
        const click_skip_seconds = (seconds, ev) => {
            const new_session_time = max(get_current_session_time() + seconds, 0)
            seek_to_time(new_session_time, ev)
        }
        const click_reverse_seconds = (seconds, ev) => {
            const reference_session_time = min(get_current_session_time(), structure_expanded[structure_expanded.length - 1][2])
            const new_session_time = max(reference_session_time - seconds, 0)
            seek_to_time(new_session_time, ev)
        }
        const seek_to_time = (time, ev) => {
            stop_notification_sounds()
            const current_time = getTime()
            start_time = current_time - time
            pause_time = current_time
            stop_song()
            unpause_this_au = null
            previous_sect = null
            ending_sound_processed = false
            if (!paused) {
                start_playing_silence()
            }
            previous_session_time = -1
            if (!paused && time < 0.001) {
                if (document.getElementById('class_begins').checked) {
                    play_notification_sound('class_begins_sound')
                }
            }
        }
        const click_skip_prev = (ev) => {
            const [i, ofs] = get_current_index_and_offset()
            if (i===null) {
                seek_to_time(structure_expanded[structure_expanded.length - 1][1], ev)
            } else if ((ofs > 2) || (i == 0)) {
                seek_to_time(structure_expanded[i][1], ev)
            } else {
                seek_to_time(structure_expanded[i-1][1], ev)
            }
        }
        const adjust_available_time = (adjustment, ev) => {
            let [i, ofs] = get_current_index_and_offset()
            while ((i < structure_expanded.length) && (structure_expanded[i][0] == "music")) {
                i+=1
            }
            if (i < structure_expanded.length) {
                adjustment = max(structure_expanded[i][1] + ofs - structure_expanded[i][2], adjustment)
                let j = i
                while ((j < structure_expanded.length) && (structure_expanded[j][0] != "music")) j++;
                if (j >= structure_expanded.length) return
                while ((j < structure_expanded.length) && ((structure_expanded[j][0] == "music") || ((adjustment > 0) && (structure_expanded[j][2] - structure_expanded[j][1] < 0.1)))) j++;
                if (j >= structure_expanded.length) return
                adjustment = min(structure_expanded[j][2] - structure_expanded[j][1], adjustment)
                structure_expanded[i][2] += adjustment
                while (i+1 < j) {
                    i += 1
                    structure_expanded[i][1] += adjustment
                    structure_expanded[i][2] += adjustment
                }
                structure_expanded[j][1] += adjustment
            }
        }
        function toggle_fullscreen() {
            if (document.fullscreenElement == canvas) {
                document.exitFullscreen()
            } else {
                canvas.requestFullscreen()
            }
        }
        function show_progress_bar_onclick() {
            const show = document.getElementById('show_progress_bar')
            const seeking = document.getElementById('progress_bar_seeking_enabled')
            seeking.checked = show.checked
            seeking.disabled = !show.checked
        }
        canvas.onclick = (ev) => {
            const boxs = max(min(canvas.width, canvas.height) / 9, 30)
            let captured = false
            if (document.getElementById('navigation_buttons_enable').checked) {
                if (ev.clientY > canvas.height-boxs-4) {
                    if (ev.clientX < boxs + 4) {
                        click_pause(ev)
                        captured = true
                    } else if (ev.clientX < 4 + boxs + 8 + boxs) {
                        click_skip_prev(ev)
                        captured = true
                    } else if (ev.clientX < 4 + boxs + (8 + boxs) * 2) {
                        click_skip_next(ev)
                        captured = true
                    } else if (ev.clientX < 4 + boxs + (8 + boxs) * 3) {
                        adjust_available_time(60, ev)
                        captured = true
                    } else if (ev.clientX < 4 + boxs + (8 + boxs) * 4) {
                        adjust_available_time(-60, ev)
                        captured = true
                    }
                }
            }
            if (document.getElementById('show_progress_bar').checked) {
                const progress_bar_height = canvas.height / 20
                if (ev.clientY < progress_bar_height) {
                    captured = true
                    if (document.getElementById('progress_bar_seeking_enabled').checked) {
                        const total_length = structure_expanded[structure_expanded.length - 1][2]
                        const next_time = ev.clientX / canvas.width * total_length
                        seek_to_time(next_time, ev)
                    }
                }
            }

            if (!captured) {
                toggle_fullscreen()
            }
        }
        const cc = canvas.getContext("2d")
        let start_time = 0
        let ending_sound_processed = false
        let previous_sect = null
        let structure_expanded = null
        function getTime () {
            return (new Date()).getTime()/1000
        }
        function play_sound_if_needed(sect, left, previous_left, sectindex) {
            const did_we_pass_marker = (time) => {
                return (left <= time) && (previous_left > time) && (time - left < 1)
            }
            let minlen = parseInt(document.getElementById('min_length_for_1min_alert').value) * 60;
            if (isNaN(minlen)) minlen = 0
            if (sect[0] == "silence") {
                if (did_we_pass_marker(5 * 60) && document.getElementById('instructors_5_minutes').checked) {
                    play_notification_sound('instructors_5_minutes_sound')
                }
                if ((sect[2] - sect[1] >= minlen) && did_we_pass_marker(1 * 60) && document.getElementById('instructors_1_minute').checked) {
                    play_notification_sound('instructors_1_minute_sound')
                }
            }
            if (sect[0] == "summary") {
                if (document.getElementById('summary').checked) {
                    const sect_len = sect[2] - sect[1]
                    if (did_we_pass_marker(sect_len)) {
                        if (sect_len == 5 * 60) {
                            play_notification_sound('instructors_5_minute_summary_sound')
                        } else {
                            play_notification_sound('summary_sound')
                        }
                    }
                }
                if (did_we_pass_marker(1 * 60) && document.getElementById('instructors_1_minute_summary').checked) {
                    play_notification_sound('instructors_1_minute_sound')
                }
            }
            if (previous_sect && (previous_sect[0] == "music") && (sect[0] != "music")) stop_song();
            if ((sect[0] == "music") && (sect != previous_sect)) {
                if (all_files.length > 0) {
                    let next_song_to_play = 0
                    for (let j=0;j<sectindex;j++) {
                        if (structure_expanded[j][0]=="music") {
                            next_song_to_play += 1
                        }
                    }
                    next_song_to_play %= all_files.length
                    play_song_at_index(next_song_to_play, sect[2] - sect[1] - left);
                }
            }
            previous_sect = sect
        }
        function min(a,b) {
            if (a<b) return a
            return b
        }
        function max(a,b) {
            if (a>b) return a
            return b
        }
        function get_progress_bar_color_of(section_type) {
            if (section_type == "music") return "cyan"
            if (section_type == "summary") return "orange"
            return "black"
        }
        let last_canvasX = null
        let last_canvasY = null
        let touch_device = false
        function drawCurrentFrame() {
            let cursor_style = "initial"
            let time = get_current_session_time()
            cc.setTransform(1, 0, 0, 1, 0, 0)
            cc.fillStyle="black"
            cc.fillRect(0, 0, canvas.width, canvas.height)
            
            let height_left = canvas.height
            if (document.getElementById('show_progress_bar').checked) {
                cc.fillStyle="red"
                const progress_bar_height = canvas.height / 20
                const total_length = structure_expanded[structure_expanded.length - 1][2]
                const progress = time / total_length
                const tick_w = canvas.width / 240
                const progress_width = (canvas.width) * progress
                cc.fillRect(0, progress_bar_height / 2, progress_width , progress_bar_height / 2)
                cc.fillStyle="grey"
                cc.fillRect(progress_width, progress_bar_height / 2, canvas.width - progress_width , progress_bar_height / 2)
                for (const f of structure_expanded) {
                    const fill_color = get_progress_bar_color_of(f[0])
                    const right_edge = f[2] * canvas.width / total_length
                    const left_edge = f[1] * canvas.width / total_length
                    cc.fillStyle=fill_color
                    cc.fillRect(left_edge, 0, right_edge - left_edge, progress_bar_height / 2)
                }
                cc.fillStyle="white"
                for (let i=0; i<structure_expanded.length - 1; i++) {
                    const f = structure_expanded[i]
                    const fill_color = get_progress_bar_color_of(f[0])
                    const fill_color_next = get_progress_bar_color_of(structure_expanded[i+1][0])
                    if (fill_color_next == fill_color) {
                        const tick_x = f[2] * canvas.width / total_length
                        // Print a tick, if color is the same
                        cc.beginPath()
                        cc.moveTo(tick_x - tick_w, 0)
                        cc.lineTo(tick_x + tick_w, 0)
                        cc.lineTo(tick_x + tick_w, progress_bar_height / 4)
                        cc.lineTo(tick_x, progress_bar_height / 2)
                        cc.lineTo(tick_x - tick_w, progress_bar_height / 4)
                        cc.fill()
                    }
                }
                if (last_canvasY != null && last_canvasY < progress_bar_height) {
                    if (document.getElementById('progress_bar_seeking_enabled').checked) {
                        cursor_style = "col-resize"
                        if (!touch_device) {
                            cc.fillStyle="rgba(255,255,255,0.4)"
                            cc.fillRect(0,0,last_canvasX, progress_bar_height)
                            /*cc.fillStyle="red"
                            cc.beginPath()
                            cc.ellipse(progress_width, progress_bar_height * 3 / 4, progress_bar_height/2, progress_bar_height/2, 0, 0, 2 * Math.PI)
                            cc.fill()*/
                        }
                    } else {
                        cursor_style = "not-allowed"
                    }
                }
                cc.setTransform(1, 0, 0, 1, 0, progress_bar_height)
                height_left = canvas.height - progress_bar_height
            }
            cc.fillStyle="white"
            let found = false
            let ii = 0
            let sect = null
            for (ii = 0; ii<structure_expanded.length; ii++) {
                sect = structure_expanded[ii]
                if ((time >= sect[1]) && (time < sect[2])) {
                    let len = sect[2] - sect[1]
                    let pos = time - sect[1]
                    let left = len - pos
                    let mprogress = (60 - left / 60) / 60
                    
                    // These are the 16:9 aspect ratio variants
                    let x = canvas.width - 20
                    let y = height_left / 2
                    let r = min(canvas.width, height_left / 2)
                    let tx = (canvas.width - height_left/2) / 2
                    let ty = height_left / 2
                    let fontsize = Math.floor(canvas.width * 0.25)

                    cc.textAlign = "center"
                    cc.textBaseline = "middle"
                    
                    const ratio = canvas.width/height_left

                    if (left >= 60) {
                        if (ratio < 0.9124767225325885) {
                            y = height_left * 74 / 100
                            fontsize = height_left * 0.25
                            ty = fontsize / 2 * 1.2
                            tx = canvas.width / 2
                            if (ratio < 0.6444981862152358) {
                                fontsize = canvas.width * 0.35

                            }
                        } else if (ratio < 1.3824975417895773) {
                            y = height_left * 74 / 100
                            ty = height_left / 3
                            tx = canvas.width * 34 / 100
                        }
                    } else {
                        mprogress = (60 - left)/ 60
                        cc.fillStyle="red"
                        
                        tx = 10
                        ty = 10
                        
                        if (ratio > 1) {
                            r = min(canvas.width / 4, height_left / 2)
                            cc.textAlign = "left"
                            cc.textBaseline = "top"
                            y = height_left - r
                        } else {
                            r = min((canvas.width - 20) / 2, height_left * 60 / 100 / 2)
                            y = height_left - r - 10
                            tx = canvas.width / 2
                            ty = height_left / 4
                            fontsize = Math.floor(canvas.width * 0.45)
                        }
                        x = canvas.width - r - 10
                        
                    }

                    cc.beginPath()
                    cc.arc(x, y, r * 0.8, Math.PI/2*3 + Math.PI * 2 * mprogress, Math.PI/2*3 + Math.PI * 2)
                    cc.lineTo(x, y)
                    cc.fill()

                    const drawTick = (angle) => {
                        cc.beginPath()
                        cc.arc(x, y, r*0.95, angle - Math.PI/180, angle + Math.PI/180, false)
                        cc.arc(x, y, r*0.85, angle + Math.PI/180, angle - Math.PI/180, true)
                        cc.fill()
                    }
                    for (let i=0; i<12; i++)
                        drawTick(Math.PI/2*3 + Math.PI * 2 - Math.PI / 2 / 3 * i)
                    cc.strokeStyle = cc.fillStyle
                    cc.lineWidth = 3.
                    cc.beginPath()
                    cc.arc(x, y, r * 0.95, 0, 2 * Math.PI)
                    cc.stroke()

                    cc.font = "" + fontsize + "px Arial"
                    
                    cc.fillText(minutes_seconds(left), tx, ty)

                    found = true
                    break
                }
            }
            if (!found) {
                let fontsize = Math.floor(canvas.width * 0.10)
                cc.font = "" + fontsize + "px Arial"
                cc.textAlign = "center"
                cc.textBaseline = "middle"
                cc.fillText("THE END", canvas.width/2, height_left/2)
            }
            if (document.getElementById('navigation_buttons_enable').checked) {
                const boxs = max(min(canvas.width, height_left) / 9, 30)
                const h = boxs * 7 / 10
                const w = boxs * 2 / 10
                const d = boxs * 2 / 10
                if (paused) {
                    cc.fillStyle="rgba(255,255,255,1)"
                } else {
                    cc.fillStyle="rgba(255,255,255,0.2)"
                }
                cc.strokeStyle=cc.fillStyle
                cc.strokeRect(4, height_left-boxs-4, boxs, boxs)
                cc.fillRect(4 + (boxs-(w*2 + d))/2, height_left-boxs-4 + (boxs - h)/2, w, h)
                cc.fillRect(4 + (boxs-(w*2 + d))/2 + w + d, height_left-boxs-4 + (boxs - h)/2, w, h)
                cc.fillStyle="rgba(255,255,255,0.2)"
                cc.strokeStyle=cc.fillStyle
                cc.strokeRect(4 + boxs + 8, height_left-boxs-4, boxs, boxs)
                cc.strokeRect(4 + boxs + 8 + boxs + 8, height_left-boxs-4, boxs, boxs)
                cc.font = "" + boxs + "px Arial"
                cc.textAlign = "center"
                cc.textBaseline = "middle"

                /* Drawing for the previous-chapter button: */
                cc.beginPath()
                cc.moveTo(4 + boxs + 8 + boxs / 2, height_left - boxs - 4 + boxs / 10)
                cc.lineTo(4 + boxs + 8 + boxs * 1 / 6, height_left - boxs - 4 + boxs / 2)
                cc.lineTo(4 + boxs + 8 + boxs / 2, height_left - boxs - 4 + boxs - boxs / 10)
                cc.fill()
                cc.beginPath()
                cc.moveTo(4 + boxs + 8 + boxs * 5 / 6, height_left - boxs - 4 + boxs / 10)
                cc.lineTo(4 + boxs + 8 + boxs * 1 / 2, height_left - boxs - 4 + boxs / 2)
                cc.lineTo(4 + boxs + 8 + boxs * 5 / 6, height_left - boxs - 4 + boxs - boxs / 10)
                cc.fill()
                /* Drawing for the next-chapter button: */
                cc.beginPath()
                cc.moveTo(4 + boxs + 8 + boxs + 8 + boxs * 1 / 6, height_left - boxs - 4 + boxs / 10)
                cc.lineTo(4 + boxs + 8 + boxs + 8 + boxs * 1 / 2, height_left - boxs - 4 + boxs / 2)
                cc.lineTo(4 + boxs + 8 + boxs + 8 + boxs * 1 / 6, height_left - boxs - 4 + boxs - boxs / 10)
                cc.fill()
                cc.beginPath()
                cc.moveTo(4 + boxs + 8 + boxs + 8 + boxs * 1 / 2, height_left - boxs - 4 + boxs / 10)
                cc.lineTo(4 + boxs + 8 + boxs + 8 + boxs * 5 / 6, height_left - boxs - 4 + boxs / 2)
                cc.lineTo(4 + boxs + 8 + boxs + 8 + boxs * 1 / 2, height_left - boxs - 4 + boxs - boxs / 10)
                cc.fill()

                cc.strokeRect(4 + (boxs + 8) * 3, height_left-boxs-4, boxs, boxs)
                cc.strokeRect(4 + (boxs + 8) * 4, height_left-boxs-4, boxs, boxs)
                cc.font = "" + (boxs/3) + "px Arial"
                cc.fillText("Time", 4 + (boxs + 8) * 3 + boxs/2, height_left-boxs-4 + boxs*4/5)
                cc.fillText("Time", 4 + (boxs + 8) * 4 + boxs/2, height_left-boxs-4 + boxs*4/5)
                cc.font = "" + (boxs/1) + "px Arial"
                cc.fillText("+",    4 + (boxs + 8) * 3 + boxs/2, height_left-boxs-4 + boxs*2.25/5)
                cc.fillText("-",    4 + (boxs + 8) * 4 + boxs/2, height_left-boxs-4 + boxs*1.8/5)

                if (found) {
                    cc.textAlign = "left"
                    cc.font = "" + (boxs/2) + "px Arial"
                    cc.fillText("" + ii + ": " + sect[0], 4 + (boxs + 8) * 5 + 2, height_left-boxs-4 + boxs*3/4)
                }

                if (last_canvasY > canvas.height-boxs-4) {
                    if ((last_canvasX < 4 + boxs + (8 + boxs) * 4)) {
                        cursor_style = "pointer"
                    }
                }

            }
            canvas.style.cursor = cursor_style
        }
        let previous_session_time = -1
        function performActions() {
            let time = get_current_session_time()
            let ii = 0
            let found = false
            let message = "The End"
            for (ii = 0; ii<structure_expanded.length; ii++) {
                let sect = structure_expanded[ii]
                if ((time >= sect[1]) && (time < sect[2])) {
                    let len = sect[2] - sect[1]
                    let pos = time - sect[1]
                    let left = len - pos
                    let previous_left = len - (previous_session_time - sect[1])
                    if (!paused)
                    {
                        play_sound_if_needed(sect, left, previous_left, ii)
                    }
                    found = true
                    message = "" + ii + ": " + sect[0]
                    break
                }
            }
            if (!found) {
                if (!ending_sound_processed) {
                    stop_playing_silence()
                    if (document.getElementById('sound_at_end').checked) {
                        let what = document.getElementById('what_to_play_at_end').value
                        play_notification_sound(what)
                    }
                    ending_sound_processed = true
                }
            }
            previous_session_time = time
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: message,
                    artist: 'Course Structure',
                })
                if (paused) {
                    navigator.mediaSession.playbackState = "paused"
                } else {
                    navigator.mediaSession.playbackState = "playing"
                }
                navigator.mediaSession.setActionHandler('play', click_pause)
                navigator.mediaSession.setActionHandler('pause', click_pause)
                navigator.mediaSession.setActionHandler('nexttrack', click_skip_next)
                navigator.mediaSession.setActionHandler('previoustrack', click_skip_prev)
                navigator.mediaSession.setActionHandler('seekforward', function() {
                    click_skip_seconds(10)
                })
                navigator.mediaSession.setActionHandler('seekbackward', function() {
                    click_reverse_seconds(10)
                })
                navigator.mediaSession.setActionHandler('stop', function() {
                    seek_to_time(structure_expanded[structure_expanded.length - 1][2], ev)
                })
            }
        }
        const anim = () => {
            drawCurrentFrame()
            requestAnimationFrame(anim)
        }
        const actions = () => {
            performActions()
            setTimeout(actions, 1000 / 20)
        }
        const resizeCanvas = () => {
            let w = window.innerWidth;
            let h = window.innerHeight;
            canvas.style.position="absolute";
            canvas.style.left="0px";
            canvas.width = w;
            canvas.height = h;
        };

        function getCurrentStructure() {
            let list = []
            for (const tr of document.querySelectorAll("#course-structure-list tr")) {
                const sel = tr.querySelector("select")
                if (sel) {
                    const min = parseFloat(tr.querySelector(".structure-line-minutes").value)
                    const sec = parseFloat(tr.querySelector(".structure-line-seconds").value)
                    list.push([sel.value, min, sec])
                }
            }
            return list
        }

        function expandStructure(structure) {
            let acc = 0
            let list = []
            for (let i=0;i<structure.length;i++) {
                const secs = structure[i][1] * 60 + structure[i][2]
                list.push([structure[i][0], acc, acc+secs])
                acc += secs
            }
            return list
        }

        const wake_lock_message = document.getElementById("wake_lock_message")
        const wake_lock_status = document.getElementById("wake_lock_status")
        if ('wakeLock' in navigator) {
            wake_lock_status.innerText = "request pending"
            wake_lock_message.style.color = "red"
            let wake_lock = null;
            async function request_wake_lock() {
                try {
                    wake_lock = await navigator.wakeLock.request('screen')
                    wake_lock.addEventListener('release', () => {
                        console.log("wake lock was released")
                        wake_lock_message.style.color = "red"
                        wake_lock_status.innerText = "released"
                    })
                    console.log("wake lock was acquired")
                    wake_lock_status.innerText = "OK, appears to have been successfully acquired"
                    wake_lock_message.style.color = "#00E000"
                } catch (err) {
                    console.log("Error while acquiring wake lock")
                    wake_lock_message.style.color = "red"
                    wake_lock_status.innerText = "error while acquiring"
                }
            }
            request_wake_lock()
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    request_wake_lock()
                }
            })
        } else {
            wake_lock_message.style.color = "red"
            if (window.location.protocol == "http:") {
                wake_lock_status.innerText = "not supported (could be because this site is being served as non-secure http://. Try downloading, and running locally.)"
            } else {
                wake_lock_status.innerText = "not supported"
            }
        }

        if (window.location.hostname!="purdeaandrei.github.io") {
            document.getElementById("network_links").style.display="none"
        }

        function start_showtime() {
            if (all_files.length==0) {
                alert("ERROR: you must have at least one song added to the playlist!")
                return
            }
            stop_song()
            structure_expanded = expandStructure(getCurrentStructure())
            document.querySelector("#setup").style.display="none"
            canvas.style.display="block"
            document.body.style.background="black"
            start_time = getTime()
            paused = false
            ending_sound_processed = false
            start_playing_silence()
            if (document.getElementById('class_begins').checked) {
                play_notification_sound('class_begins_sound')
            }
            document.getElementsByTagName('body')[0].style.margin="0 0 0 0"
            resizeCanvas()
            anim()
            actions()
            window.onresize = () => {
                resizeCanvas();
                drawCurrentFrame();
            };
            if (document.getElementById('navigation_keyboard_shortcuts_enable').checked) {
                document.addEventListener('keydown', (event) => {
                    if (event.isComposing || event.keyCode === 229) {
                        return;
                    }
                    switch (event.keyCode) {
                        case 70: /* F pressed */
                            toggle_fullscreen()
                            break
                        case 32: /* space */
                            click_pause(event)
                            break
                        case 34: /* page-down */
                            click_skip_prev(event)
                            break
                        case 33: /* page-up */
                            click_skip_next(event)
                            break
                        case 39: /* right arrow */
                            click_skip_seconds(10, event)
                            break
                        case 37: /* left arrow */
                            click_reverse_seconds(10, event)
                            break
                        case 38: /* up arrow */
                            click_skip_seconds(60, event)
                            break
                        case 40: /* down arrow */
                            click_reverse_seconds(60, event)
                            break
                        case 107: /* numpad + */
                        case 187: /* alpha key with plus symbol (next to backspace) */
                            adjust_available_time(60, event)
                            break
                        case 109: /* numpad - */
                        case 189: /* alpha key with minus symbol (second one next to backspace) */
                            adjust_available_time(-60, event)
                            break
                    }
                })
            }
            if (document.getElementById('show_progress_bar').checked) {
                canvas.addEventListener('mousemove', (event) => {
                    const rect = canvas.getBoundingClientRect()
                    last_canvasX = event.clientX - rect.left
                    last_canvasY = event.clientY - rect.top
                })
                canvas.addEventListener('mouseover', (event) => {
                    const rect = canvas.getBoundingClientRect()
                    last_canvasX = event.clientX - rect.left
                    last_canvasY = event.clientY - rect.top
                })
                canvas.addEventListener('mouseout', (event) => {
                    last_canvasX = null
                    last_canvasY = null
                })
                canvas.addEventListener('touchstart', (event) => {
                    touch_device = true;
                })
                canvas.addEventListener('touchend', (event) => {
                    touch_device = true;
                })
            }
        }
    </script>
  </body>
</html>
